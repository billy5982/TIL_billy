자료구조

-
- 여러 데이터의 묶음을 저장하고, 사용하는 방법을 정의한 것.
- 데이터는 분석하고 정리하여 활용해야만 의미를 가질 수 있음
- 특정한 상황에 놓인 문제를 해결하는 데에 특화

스택

-
- 쌓다 , 쌓이다, 포개지다 뜻을 가지고 있음, 데이터를 순서대로 쌓는 구조
- 후입선출 : 먼저 들어간 데이터는 가장 나중에 나옴, 제일 늦게 들어간 데이터가 제일 먼저 나옴  
  **data 입력 : push, data 출력 : pop**
- **LIFO(Last IN First Out) , FILO(First in Last Out)**
- 데이터를 하나씩 넣고 뺄 수 있다, 하나의 입출력 방향
- 브라우저에서 뒤로 가기, 앞으로 가기 할 때

## Que

- 줄을 서서 기다리다, 대기 행렬
- 선입선출 : 먼저 들어간 데이터(data)가 먼저 나오는 FIFO(First in First Out)
- 데이터 입력 : enqueue, 데이터 출력 : dequeue

큐, 스택 진행방향

- ![알고리즘 연습장](https://user-images.githubusercontent.com/104412610/191519493-d8ef693d-ff43-4ad5-b48a-b9bc1a5c7572.png)
  큐 프린터 알고리즘
- ![알고리즘 연습장 2](https://user-images.githubusercontent.com/104412610/191520155-8e46290f-cb1b-44de-9669-f1319b2e657d.png)
  ![IMG_0012](https://user-images.githubusercontent.com/104412610/191520171-5e0d10d5-c868-4d81-a62b-792c6c97b292.jpg)

## Tree

- 단뱡향 그래프, 하나의 뿌리로부터 가지가 사방으로 뻗은 형태
- 루트 : 하나의 꼭짓점 데이터(트리의 시작점)
- 노드 : 각 데이터 부모와 자식 구조로 이루어져 있음(트리 구조의 시작점이 되는 노드)
- 리프 노드 : 자식이 없는 노드
- 깊이(depth) : 루트로부터 하위 계층의 특정 노드까지의 깊이, 루트가 0, 그 자식노드들은 0+깊이
- 레벨(level) : 같은 깊이를 가지고 있는 노드를 묶어서 레벨이라고 함
- 높이(height) : 리프 노드를 기준으로 **루트**까지의 높이
- 서브 트리 : 트리 구조를 갖춘 작은 트리

## 이진트리

- 자식 노드가 최대 두개인 노드들로 구성된 트리
- 자식 노드가 없을 수도(리프 노드) 하나만 있을 수도 있음
- 노드를 기준으로 노드 left엔 노드보다 작은 수, 노드 right엔 노드보다 큰 수
- 정 이진 트리 : 각 노드가 0개 혹은 2개의 자식 노드
- 포화 이진 트리 : 정 이진트리 이면서 완전 이진트리인 경우, 모든 리프 노드의 레벨이 동일, 모든 레벨이 가득 채워져 있는 트리
- 완전 이진 트리 : 마지막 레벨을 제외한 모든 노드가 가득 차있어야함. 마지막 레벨의 노드는 전부 차있지 않아도 되지만 왼쪽으로 채워져야 함.
  <img src="https://user-images.githubusercontent.com/104412610/191528518-5a9d9252-ee94-422f-8d3e-15bd9276f8a9.png"  width="200" />
  <img src="https://velog.velcdn.com/images%2Fvermonter%2Fpost%2F691e0ee8-50d3-4f25-9042-6fb4f0afdcba%2Fimage.png"  width="200" />
- 전위 순회 : 가장 먼저 방문하는 노드는 루트 -> this.vaule를 확인하고 left로 순회를 시작, left 순회가 끝나면 right 순회 시작, 부모 - 좌측 자식 - 우측 자식
- 중위 순회 : 중위 순회는 루트를 가운데 두고 순회. root의 left를 먼저 확인. 루트를 기준으로 왼쪽에 있는 노드의 순회가 끝나면 루트를 거쳐 오른쪽에 있는 노드로 이동 -> left 확인 -> this.value -> right 확인
- 후위 순회 : 루트를 가장 마지막에 순회 -> left , right, this,value 순

## 그래프

- 여러개의 점들이 서로 복잡하게 연결되어 있는 구조
- 직접적인 관계는 두 점(vertex : 트리의 노드라 생각)을 이어주는 선이 있음(edge 간선)
- 간선(edge) : 정점 간의 관계
- 인접 정점 : 하나의 정점에서 간선에 의해 직접 연결되어 있는 정점
- 가중치 / 비가중치 그래프 : 연결의 강도가 얼마나 되는 지.(서울 부산 500km)
- 무 방향/방향 그래프 : 무 방향 그래프의 경우 간선이 서로 연결됨. 서로 통해 있음. 방향 그래프는 일반통행이라고 생각하면 됨.
- 진입차수 / 진출차수 : 정점에 진입,진출하는 간선이 몇개 인지
- 인접 : 두 정점간에 간선이 직접 이어져있다면 두 정점은 진접한 정점
- 자기 루프 : 정점에서 진출하는 간선이 곧바로 자신한테 진입하는 경우(다른 정점을 거치지 않음)
- 사이클 : 한 정점에서 시작해서 다시 해당 정점으로 돌아갈 수 있는 경우

## 그래프 탐색

- 하나의 정점에서 시작, 모든 정점을 한번씩 탐색하는 것이 목적
- BFS(Breadth-First Search, 너비 우선 탐색)
  - 가까운 정점부터 탐색, 탐색할 정점이 없을 떄 떨어져 있는 정점을 순서대로 방문, 너비를 우선적으로 탐색하는 방법. 가장 빠른 경로를 찾을 떄?
  - 보통 queue를 이용해서 구현
- DFS(Depth First Search)
  - 하나의 경로를 끝까지 탐색, 해당 원하는 값이 아니라면 다음 경로로 넘어가서 탐색
  - 재귀 혹은 Stack을 이용

그래프 종류

- 인접 행렬 : 배열 내에 배열이 있는 행렬의 형태,배열의 인덱스 번호가 vertex, 해당 vertex의 배열 내부 값이 간선(edge)로 생각
  인접 리스트 : vertex가 객체의 키로 있고 연결되어있는 간선(edge)이 값으로 존재

|                | 인접 행렬                            | 인접 리스트            |
| -------------- | ------------------------------------ | ---------------------- |
| 공간           | 배열이기 때문에 리스트보다 많이 차지 | 객체 형태 더 적게 차지 |
| 간선 찾기      | 모든 행렬을 순회해야함               | 객체 key하고 값을 확인 |
| 특정 간선 찾기 | indexOf 이용                         | 더 빠름                |

![알고리즘 연습장 3](https://user-images.githubusercontent.com/104412610/191538841-2614ce0a-0903-4971-9823-2dd7b9bf2915.png)

## 행렬 그래프 연결 확인 알고리즘

![알고리즘 연습장4](https://user-images.githubusercontent.com/104412610/191539818-ad2efd69-dc4a-42e2-aa8c-6cb21309da05.png)
![알고리즘 연습장5](https://user-images.githubusercontent.com/104412610/191539822-55130830-f819-49b8-aac5-9b1e70907416.png)
![알고리즘 연습장5 2](https://user-images.githubusercontent.com/104412610/191539826-f56ece45-211f-444e-9c42-2dd48e341893.png)
![알고리즘 연습장 4](https://user-images.githubusercontent.com/104412610/191539812-16e7f07a-b050-4ed8-b46d-94a9580e3b02.png)
