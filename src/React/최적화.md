<details>
<summary ><strong>최적화 정리</summary>
<div markdown="1">

## 최적화(Optimization) : 주어진 조건으로 최대효율을 내는것

#### 분야에서의 최적화

- 물류업 : 가능한 적은 비용으로 정해진 기간 내에 운송이 완료될 수 있는 최적의 답안을 찾는 것
  - 기한이 길다면 적은 비용으로 도착할 수 있는 운송수단 제공
  - 기한이 짧다면 비싸더라도 기한 내에 도착할 수 있는 운송수단 제공
- 컴퓨터 공학 : 적은 리소스를 소모하면서 가능한 빠르게 원하는 결과를 도출
  - 예) 알고리즘 문제 -> 메모리를 조금이라도 덜 소모하거나 연산 횟수가 한번이라도 적은 코드가 실행속도가 빠름.
- 웹페이지 : 최대한 빠른 속도로 화면에 표시하는 것

#### 최적화의 필요성

- 이탈률 감소 : 화면을 불러오는 시간이 길어진다면 사용자가 웹 사이트를 이탈할 확률이 올라감
- 전환율 증가
  - 전환율 : 웹사이트 방문한 사용자가 회원가입, 상품 구매, 게시글 조회, 다운로드 등의 행위를 한 방문자의 비율을 의미
- 수익 증대 : 이탈률이 감소하고, 전환율이 증가하면 트래픽 증대 및 회원 수 증가로 이어짐. -> 수익 증대로도 이어짐
- 사용자 경험 향상
  - 로딩이 느릴경우 좋은 UX를 기대하긴 어려움. 스켈레톤 같은 로딩은 사용자를 기다리게하는 것이며, 화면의 속도를 증가시키는 것보다 좋은 UX를 얻기엔 힘듬

## 최적화 기법

**1. HTML,CSS 코드 최적화**

#### 1. HTML 최적화

1.  DOM 트리 가볍게 만들 것
    - 복잡도가 클 수록 DOM트리가 변경되었을 때 계산 시간이 올라감. 불필요하게 깊이를 증가시키는 요소가 있다면 삭제해야함.(불필요한 자식요소를 제거)
2.  인라인 스타일 사용하지 않기
    - 인라인 스타일을 사용하면 중복된 코드를 작성할 경우가 생김.-> 클래스로 묶어서 사용하는 것이 효율적
    - 불필요한 코드는 가독성을 떨어뜨리며, 파일의 크기를 증가 시킴

#### 2. CSS 최적화

1.  사용하지 않는 CSS 제거
    - CSSOM 트리는 CSS 파일을 전부 읽고 난 다음의 생성됨. 불필요한 코드가 있다면 해당 트리의 완성을 늦춤.
    - CSS 코드를 사용하던 요소가 삭제되었다면 해당 CSS 코드만 남게 된건 아닌지 확인하고 삭제할 것
2.  간결한 셀렉터 사용
    - 셀렉터가 복잡할수록 스타일 계산과 레이아웃에 시간을 더 많이 소모함.

````css
// 복잡한 CSS 셀렉터 예시
.cart_page .cart_item #firstItem { ... }
// 가능한 한 간결하게 작성해줍니다.
.cart_item { ... }```
````

<hr/>

#### **2. 리소스 로딩 최적화**

1. CSS 파일 불러오기

   - CSSOM은 CSS 파일을 전부 읽고 나서 구성됨. 최대한 빠르게 구성할 수 있도록 HTML head(문서 최상단) 배치하는 것이 좋음

2. Javascript 파일 불러오기
   - HTML 파싱중에 `script`를 만나면 파싱을 중단하고 js코드를 불러옴.
   - `script`가 HTML 중간에 배치되어 있다면? DOM요소를 구성할 경우 해당 태그 위치 이전에 생성된 DOM까지만 접근 가능 -> 의도한 대도 화면에 표시되지 않음
   - DOM 트리 완료 시점인 HTML 문서 최하단에 배치하는 것이 좋음

<hr/>

#### **3. 브라우저 이미지 최적화**

1. 이미지 스프라이트 : 여러개의 이미지를 모아 하나의 스프라이트 이미지로 제작하고, CSS `background-position`, `width`,`height`만 이용해서 표시하고 싶은 이미지를 표시하는 것. 한번의 이미지 요청으로 대부분의 개별 이미지를 사용할 수 있음  
   <img width="363" alt="image" src="https://user-images.githubusercontent.com/104412610/194471481-1a221b24-ab34-4d30-95d1-8cd4834200a0.png">
2. 아이콘 폰트 이용하기

- 모든 아이콘을 이미지로 사용하지 않고 아이콘 폰트를 사용하여 용량을 줄일 수 있음
  예) Font Awesome

```js
// 핵심 패키지 설치
npm i --save @fortawesome/fontawesome-svg-core
// 아이콘 패키지 설치 (무료버전)
npm i --save @fortawesome/free-solid-svg-icons
npm i --save @fortawesome/free-regular-svg-icons
npm i --save @fortawesome/free-brands-svg-icons
// Font Awesome React 구성 요소 설치
npm i --save @fortawesome/react-fontawesome@latest

// 사용하고 싶은 아이콘 정보를 확인 후, 불러와서 사용하면 됨. 아이콘 이름은 camelCase로 작성
```

3. Webp, AVIF 이미지 포맷 이용
   | / | PNG | JPEG |
   | ---- | ------------- | ---------------- |
   | webp | 용량 26% 감소 | 용량 25~35% 감소 |
   | AVIF | 용량 20% 감소 | 용량 50% 감소 |

- 두 포맷은 최신 포맷이므로 지원하지 않는 브라우저가 존재 이때는 picture 태그를 이용

```html
<picture>
  <!-- img 요소의 다중 이미지 리소스를 위한 컨테이너 -->
  <!-- srcset에 정의한 포맷을 지원하지 않으면 해당 source태그는 무시됨. -->
  <source srcset="logo.webp" type="image/webp" />
  <img src="logo.png" alt="logo" />
</picture>
```

4. CDN 사용하기

- 유저와 서버의 거리가 멀다면 지연또한 늘어남. CDN은 이를 해결하고자 세계 곳곳에 분포한 분산된 서버에 콘텐츠를 저장
- CloudFront, CloudFlare와 같은 CDN 서비스 참고

## 캐시관리

- 캐시 : 다운로드 받은 데이터나 값을 미리 복사해 놓는 임시 장소
- 서버에서 응답으로 `Cache-Control`을 작성해서 보내주면, 해당 데이터를 캐시 유효기간동안 사용가능
- 캐시 유효기간 내라면 서버에 요청을 보내기전 브라우저는 캐시를 먼저 확인
- 캐시 이용 효과
  - 캐시가 유효한 시간 동안 네트워크 리소스 아낌
  - 파일을 다시 받아올 필요가 없어져서 브라우저 로딩속도 빠름
  - 로딩이 빨라진 만큼 빠른 사용자 경험 제공 가능
- 캐시 검증 헤더와 조건부 요청
  - 캐시 유효기간이 지났다면?? 다시 똑같은 정보를 요청해야하나??
  - 캐시 검증헤더 : 캐시에 저장된 데이터와 서버의 데이터가 동일한지 확인하기 위한 정보를 담은 응답 헤더
    - `Last-Modified` : 데이터가 마지막으로 수정된 시점을 의미, `If-Modified-Since`와 묶어서 사용
    - `Etag` : 데이터의 버전을 의미하는 응답 헤더, 조건부 요청 헤더인 `If-None-Match`와 묵어서 사용
  - 조건부 요청 헤더 : 캐시의 데이터와 서버의 데이터가 동일하다면 재사용하게 해달라는 의미의 요청헤더
    - `If-Modified-Since` : 캐시된 리소스의 `Last-Modified` 값 이후에 서버 리소스가 수정되었는지 확인, 수정되지 않았다면 캐시된 리소스 사용
    - `If-None-Match` : 캐시된 리소스의 ETag 값과 현재 서버 리소스의 ETag 값이 같은지 확인하고 캐시된 리소스 사용
- 캐시 검증 헤더, 조건부 헤더 사용 예시
  - `Last-Modified`, `If-Modified-Since`
    1. 첫 번째 요청 시 응답에서 캐시 유효시간 + 파일 + `Last-Modified`를 받아옴(캐시에 저장)
    2. 캐시 시간 이후 요청 시 요청 헤더에 `If-Modified-Since`을 적고 캐시에 저장된 `Last-Modified`를 같이 보냄
    3. 서버와 캐시 데이터가 동일한 데이터임이 검증된다면, 서버에서 304 Not Modified라는 응답을 보내주고 캐시 데이터의 유효 시간이 갱신, 해당 데이터 재사용 가능
       **Etag도 비슷한 맥락, 버전을 비교, 보통 둘을 같이 사용함 **

## Tree Shaking : 불필요한 코드 제거

- JS 파일 크기의 증가, 요청 횟수의 증가한 만큼 파일이 오고 가는 동안 화면 표시가 늦어지기 때문에 트리 쉐이킹을 통해 파일 크기를 줄이면 최적화에 도움이 됨

### JavaScript 트리 쉐이킹

- 웹팩 4버전 이상을 사용 시 ES6 모듈을 대상으로는 기본적인 트리쉐이킹 제공됨. React도 트리쉐이킹 가능

#### 필요한 모듈만 import

- import 구문을 이용해서 라이브러리를 전체 불러오는 것이 아닌 필요한 코드만 불러와서 사용
- ```jsx
    import React from 'react' X
    import {useState,useEffect} from 'react' O
  ```

#### Babelrc 파일 설정

- Bable은 자바스크립트 문법이 구형 브라우저에서도 호환 가능하도록 ES6를 ES5로 변환하는 라이브러리
- ES5 문법은 import 지원 x -> require로 불러오는 데 require은 export 되는 모듈을 모두 불러오기 때문에 필요한 모듈만 import해도 전체 모듈이 불러와짐
- ````js
    {
        “presets”: [
          [
            “@babel/preset-env”,
            {
          "modules": false
            }
          ]
        ]
    }```
  ````

#### sideEffect 설정

- 웹팩은 사이드 이펙트를 일으킬 수 있는 코드(순수 함수X)경우 사용하지 않는 코드라도 트리쉐이킹 제외
- ```js
    //package.Json
    {
     "name": "tree-shaking",
    "version": "1.0.0",
    "sideEffects": false
    }
  ```

#### ES6 문법 사용하는 모듈 사용

- 트리쉐이킹 적용되지 않는 라이브러리가 존재한다면 어떤 문법을 사용하고 있는 지 확인이 필요함
- 일부만 ES5 문법을 사용하는 경우라면 해당 모듈을 대체할 수 있으면서 ES6를 지원하는 다른 모듈을 사용하는 것이 트리쉐이킹에 유리

## Lighthouse : 사이트 검사, 성능 측정할 수 있는 도구

- 분석 결과 항목

  - Performance(웹 성능 측정) : 화면에 콘텐츠가 표시되는 시간, 표시된 후 사용자와 상호작용하기까지의 걸리는 시간, 화면에 불안정한 요소 측정
  - Accessibility(웹 페이지 접근성) : 대체 텍스트 작성, 배경색과 콘텐츠 색상의 대비, 적절한 WAI-ARIA 속성 사용했는 지 등
  - Best Practices(웹 표준 모법 사례) : HTTPS 프로토콜, 콘솔창에 오류가 표시 되지 않는 지 등
  - SEO(검색 엔진 최적화) : `<meta>`요소 잘 작성되어 있는지, 텍스트 크기가 읽기에 좋은지, robots.txt가 유효한지
  - PWA(모바일 애플리케이션에서의 작동) : 앱 아이콘 제공하는지 스플래시 화면이 있는지, 화면 크기에 맞게 콘텐츠를 적절하게 배치 했는지 -> 체크리스트로 확인

- Perfermance 측정 메트릭
  - First Contentful Paint(성능 지표)
    - 페이지 첫 접근 시 DOM 컨텐츠의 첫번째부분을 렌더링하는 데 걸린 시간 측정
    - 이미지 파일까지 렌더링 되기전, 딱 시작됐을 때 가장 먼저 컨텐츠가 보이는 데 까지 걸리는 시간
    - FCP가 1.8초 이하여야 함.
  - Largest Contentful Paint : 가장 큰 컨텐츠 렌더 시간(큰 콘텐츠-이미지 텍스트 블록)
  - Speed Index(성능 지표)
    - 페이지 로드 동안 얼마나 빨리 컨텐츠가 시각적으로 표시되는지를 측정
    - 페이지 로딩과정을 프레임마다 캡쳐, 프레임 간 화면에 보이는 요소들을 계산
    - 0-3.4(s) : fast, 3.4-5.8(s) : moderate, Over 5.8 : slow
  - Time to interactive : 페이지가 로드되는 시점부터 사용자와의 상호작용이 가능한 시점까지의 시간 측정
  - Total Blocking Time : 페이지가 유저와 상호작용하기까지의 막혀있는 시간 측정
  - Cumulative Layout Shift : 화면에서 이리저리 움직이는 요소(불안정한 요소)가 있는 지를 측정, 사용자에게 컨텐츠가 화면에서 얼마나 많이 움직이는지(불안정한 지)를 수치화한 지표
  </div>
  </details>

## 코드스테이츠 lightHouse 확인

![image](https://user-images.githubusercontent.com/104412610/194485058-61c427ce-2e27-4752-aba3-d6f903fc6017.png)
![image](https://user-images.githubusercontent.com/104412610/194485114-a5ca3e7d-0d3e-4378-aa4a-8adc66b691b5.png)

- 차세대 형식을 사용해 이미지 제공하기?
  - WebP 및 AVIF와 같은 이미지 형식은 PNG나 JPEG보다 압축률이 높기 때문에 다운로드가 빠르고 데이터 소비량
  - 사파리 같은 곳은 WebP,AVIF를 지원하지 않음
  - 배운 `<picture>`을 사용하면 어떨까??
- HTTP/2를 사용할 것???
  - HTTP/2는 유선을 통해 이동하는 데이터를 줄여 페이지 리소스를 더 빠르게 제공합니다.
  - HTTP2는 요청과 응답의 멀티플렉싱을 지원하기 때문
  - ![image](https://user-images.githubusercontent.com/104412610/194485912-b241e544-2644-435d-908a-ae9bd9e9bcba.png)
- 오프스크린 이미지 지연
  - 보통 사진이 많은 포스팅에서 많이 발생된다?
  - lazy load라는 방식을 이용 -> 한번에 모든 텍스트와 사진을 불러오는 것이 아닌 휠을 내릴 떄마다 화면에 보여지는 부분의 사진들을 순차적으로 불러오게 하는 기능
  - [출처](https://maroenispace.tistory.com/109)
- 사용하지 않는 코드 줄이기
  - Chrome DevTools 의 [Coverage 탭](https://developer.chrome.com/docs/devtools/coverage/)에서 사용하지 않는 코드를 한줄씩 분석 가능
- 자바스크립트 줄이기
  - 웹팩 및 terser을 보통 이용
- 레거시 JavaScript를 최신 브라우저에 제공하지 않기
  - ES5 대신 ES2015+ 코드 -> 좀더 확인이 필요
