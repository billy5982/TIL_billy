## React Virtual DOM : 가상 DOM

리액트 : Virtual DOM이라는 가상 DOM이 존재(실제 DOM의 사본같은 존재지만 훨씬 가벼움)

## DOM?(Document Object Model)

- 자바스크립트 같은 스크립팅 언어가 DOM에 접근하여 조작할 수 있게 태그들을 트리구조로 객체화 시킨 것.
- 트리 : 데이터 저장보다는 저장된 데이터를 효과적으로 탐색하는 구조(업데이트가 빠름)
- DOM은 UI의 변경이 감지되면 해당 변경사항을 업데이트 시킴(하나가 변경되어도 전체를 다시 랜더링)
- 조작 정도가 많아진다면 전체를 업데이트하기 때문에 속도가 저하됨(리플로우가 발생됨)
  - 리플로우 -> 레이아웃 과정과 페인팅 과정이 다시 실행되는 것

## Virtual DOM

- REAL DOM 보다는 훨씬 가벼움, 가상 UI요소를 메모리에 유지 시키고 React DOM과 같은 라이브러리를 통해 실제 DOM과 동기화를 시킴.  
  (이사를 직접 하는 것과 이사 생각만 하는것? 으로 생각해놓을 것.)
- UI의 변화가 일어나면 트리 구조로 표현이 되는 가상 DOM을 제작, 요소의 상태가 변경되면 **새로운 DOM 트리를 제작해서 이전 DOM과 새로운 DOM을 비교**하여 **변화된 부분만 리렌더링**
- 자바스크립트의 객체형태로 존재

## 탐색 방식

- 최소한의 변경 사항만 업데이트 시켜주기 위해 새로운 DOM, 이전 DOM을 비교
- Virtual DOM에서 모든 변경 사항이 업데이트 되었다면 Real DOM의 단 한번 렌더링
- 해당 비교 과정은 유사 BFS(너비 우선 탐색), 레벨 순서대로 순회함,
- 부모요소가 확인 되었다면 노드 및 자식요소를 순회 -> 재귀적 처리

## 부모 앨리먼트가 변경된다면?

- 만약 요소를 감싸고 있는 부모요소가 바뀐다면? 이전 부모요소를 파괴(내부의 값도 파괴되는 것 -> 보존되어 있는 상태(State)도 파괴되는 것)

## 자식 앨리먼트가 변경된다면?

- 순서대로 노드의 변화를 감지하는 데 만약 순서는 동일하지만 추가되는 데이터가 맨앞에 있다면?? 이전 DOM의 첫번째는 새로운 DOM의 두번째에 존재하게 됨. 그렇게 되면 이전 DOM의 첫번째와 새로운 DOM의 첫번째(새로 생긴 데이터)가 다르기 때문에 전체를 다시 구성하게 됨. -> 사실 상 변화된 부분은 하난데??? 이를 해결해주기 위해 **key**가 탄생!

## <span style = 'font-size:18px'>key : 자식 노드에 key를 지정해서 key를 비교하고, 추가된 키의 정보만 리렌더링 해줌

- 보통 데이터 베이스상의 고유한 값을 부여(데이터의 아이디), 없다면 데이터 배열의 인덱스 값이라도 넣어준다.
- 전역적으로 유일하지 않아도 되며, 형제 사이에만 구별되면 됨.
