## IP,IP packit,UDP,TCP

**회선교환 방식**

- 발신자와 수신자 사이에 데이터를 전송할 전용선을 미리 할당하고 둘을 연결하는 것이 특징
- 회선 교환 중간에서 발신자와 수신자를 연결하는 오퍼레이터가 존재했음.
- 나하고 친구가 있다고 가정. 이 둘은 각자의 회선을 가지고 있고, 전화를 하려면 중간 오퍼레이터가 서로의 회선을 연결해줘야 함.  
  다른 친구에게 전화가 온다면? 이미 친구와 통화중이기 때문에 회선을 사용하고 있어서, 기다려야함.

**패킷교환 방식**

- 회선교환 방식의 단점을 보완, 패킷이라는 단위로 데이터를 잘게 나누어 전송하는 방식
- 패킷에는 출발지와 목적지 정보가 있고, 이에 따라 패킷이 목적지를 향해 가장 효율적인 방식으로 이동할 수 있음.
- 특정 회선이 전용선으로 할당되지 않기 때문에 효율적으로 데이터를 전송할 수 있음.

## IP/IP Packet

- 복잡한 인터넷 망 속 수많은 노드들을 지나 어떻게 클라이언트와 서버가 통신할 수 있을 까?(노드 = 하나의 서버 컴퓨터를 의미)

- IP주소를 컴퓨터에 부여하여 이를 이용해 통신함. IP는 지정한 IP 주소에 패킷이라는 통신 단위로 데이터를 전달.

- 패킷은 소포 비유 가능. IP패킷은 소포방식을 데이터 통신에 적용한 것

- 내 컴퓨터에서 원하는 컴퓨터(서버)로 패킷을 보내면?  
  해당 목적지IP를 보고 노드(서버 컴퓨터)들이 목적지 IP에 도달시키기 위해 서로 데이터를 전달  
  목적지 서버에서도 출발지 IP를 확인하여 응답을 보냄.

- IP프로토콜의 한계
  - 비연결성
    - 패킷을 받을 대상이 없거나 서비스 불능 상태에도 패킷을 전송
  - 비신뢰성
    - 중간에 패킷이 사라져도 클라이언트가 파악할 수 없음
    - 패킷의 순서를 보장할 수 없음
      - 패킷들이 서로 다른 노드를 통해 전달될 수도 있는데 클라이언트가 의도하지 않은 순서대로 패킷이 전달될 수도 있음.

## OSI 7계층, TCP/IP 4계층

- 7 계층(응용 계층)
  - HTTP,DNS,SSL,SMTP,FTP
  - 채팅에서 안녕이라고 하고 전송을 누르면 7 계층을 통해 해당 메세지를 HTTP 메세지로 변경하고 요청
  - 사용자와의 인터페이스를 제공하는 계층, 사용자가 실행하는 응용프로그램
- 6 계층(표현 계층)
  - GIF,JPEG,MPEG,MIME,ZIP,ASCII
  - 응용 계층으로 전달하거나, 전달받는 데이터를 인코딩 또는 디코딩하는 계층(번역기 역할)
- 5 계층(세션 계층) - RPC, SQL, NETBOIS, Sockets - 세션 연결의 설정과 해제, 세션 메시지 전송 등의 기능을 수행, 컴퓨터 간의 통신 방식에 대해 결정하는 계층, 작업을 마친 후엔 연결을 끊는 역할 - 소켓이란 ? 프로그램이랑 네트워크랑 데이터를 송수신할 수 있게 만들어진 연결부 - HTTP 메세지를 소켓에 담음 그후 데이터를 전송 계층으로 전달  
  ------ 위로 어플리케이션 계층 ------
- 4 계층(전송 계층)
  - TCP, UDP, NETBEUI
  - 컴퓨터간 신뢰성 있는 데이터를 주고 받을 수 있게 서비스를 제공하는 계층, 데이터들이 실제로 정상적으로 보내지는 지 확인하는 역할, 패킷이 유실되거나 순서가 바뀌는 경우를 바로 잡아주는 역할
  - IP 패킷의 출발지 IP와 목적지 IP정보를 보완할 수 있는 출발지 PORT,목적지 PORT,전송 제어, 순서, 검증 정보등을 포함함
- 3 계층(네트워크 계층) - IP, ICMP  
   - 실제 네트워크 간에 라우팅, 라우팅 -> 네트워크 안에서 통신 데이터를 짜여진 알고리즘에 의해 최대한 빠르게 보낼 최적의 경로를 선택하는 과정 - TCP 데이터와 IP데이터를 담아서 데이터 링크 계층으로 이동  
  ------ 위로 전송 계층 ------
- 2 계층(데이터 링크 계층)
  - FDDI, Ethernet, PPP
  - 네트워크 기기 간의 데이터 전송 및 물리주소를 결정하는 계층
  - 물리 계층에서 들어온 전기 신호를 모아 알아 볼 수 있는 데이터로 정제
    ------ 인터넷 계층 ------
- 1 계층(물리 계층)
  - CDMA, GSM, NICs, CSMA/CD, Fiber
  - 시스템 간의 물리적인 연결과 전기 신호를 변환 및 제어하는 계층, 물리적 연결과 관련된 정보를 정의, 전기 신호를 전달하는 데 초점, 들어온 전기 신호를 그대로 잘 전달하는 것이 목적  
    ------ 네트워크 인터페이스 계층 ------

데이터 전송자 -> 7계층에서 1계층(각 계층에서 필요한 정보를 데이터에 추가하는 것-캡슐화)-> 물리 계층에서 전기 신호로 변환되어 수신측에 전송 -> 1계층에서 7계층(헤더를 제거해나가는 것 - 역 캡슐화) -> 데이터 수신자에게 전달

## 4계층의 TCP, UDP

- TCP 특징
  - 연결 지향 - TCP 3 way handshake
    - 클라이언트가 서버에 접속 요청하는 SYN(너 거기 존재하니?)을 보냄
    - 서버는 요청을 받고 수락한다는 ACK(내가 존재해!), SYN(너는 존재하니?) 설정된 패킷을 클라이언트에 발송.  
      서버 대기(클라이언트가 ACK로 응답을 하길 원함)
    - 클라이언트가 ACK(응 나도 존재해)를 서버에게 보냄. 연결 성립!
    - 이제 데이터를 전달할 수 있음
  - 데이터 전달 보증
    - 데이터 전송이 성공적으로 이뤄지면 응답을 돌려주기 때문에 비연결성을 보완할 수 있음.
  - 순서 보장
    - 순서대로 패킷이 전달되지 않으면 TCP 세그먼트에 있는 정보를 토대로 다시 패킷 전송을 요청할 수 있음.(서버가 클라이언트에게)
    - 신뢰할 수 있는 프로토콜
- UDP 특징
  - 기능이 거의 없음
  - 비 연결 지향 (3 way handshake X)
  - 데이터 전달 보증 X
  - 순서 보장 X
  - 데이터 전달 및 순서가 보장되지 않지만 단순하고 빠름
  - 신뢰성보다는 연속성이 중요한 서비스(스트리밍)에서 자주 사용
  - 대신 커스터마이징이 가능 TCP보단 아니지만 어느정도의 TCP의 순서보장이라던지, 데이터 전달보증을 가져갈 수 있음.

## TCP/IP 4계층

- 4계층 : 어플리케이션 계층 : OSI 계층의 세션 계층, 표현 계층, 응용 계층에 해당 TCP/UDP 기반의 응용프로그램을 구현할 때 사용
- 3계층 : 전송 계층 : 전송계층에 해당. 통신 노트간의 연결을 제어, 신뢰성 있는 데이터 전송을 담당
- 2계층 : 인터넷 계층 : 네트워크 계층에 해당. 통신 노드 간의 IP 패킷을 전송하는 기능 및 라우팅을 담당
- 1계층 : 네트워크 인터페이스 계층 : 물리 계층과 데이터 링크 계층에 해당, 물리적인 주소로 MAC을 사용  
  서버 클라이언트는 모두 7계층 응용계층에서 동작함.

## HTTPS

HTTPS?? HTTP+ Secure의 약자 -> HTTP를 더 안전하게 사용할 수 있음을 의미  
HTTPS는 HTTP 요청과 응답을 암호화하기 떄문

**암호화 방식**  
암호화할 때 사용할 키, 암호화 해석(복호화)하는 키가 필요.  
**대칭 키** : 암호화키 === 복호화 키

- 하나의 키만 사용, 암호화한 키로 복호화 가능
- 비대칭 키의 비해 연삭속도 빠름
- 키를 주고 받는 과정에서 탈취 당했을 경우 암호화가 소용 없음 -> 키 관리가 중요

**비대칭키(공개 키)** : 암호화키 !== 복호화 키

- 비대칭 키에는 2개의 키가 존재 => 공개 키, 비공개 키
- 공개 키 : 누구든 접근 가능. 누구든 해당 **공개키를 사용해서 암호화**
- 비밀 키 : 아무나 공개키를 이용해서 정보를 암호화 했다면 비밀 키를 가진 사람만 그 내용을 해석(복호화)할 수 있음
- 요청을 하는 **사용자가 공개 키**, 요청을 받는 **서버가 비밀 키**를 가짐, 서버가 해킹당하지 않는 이상 탈취되지 않음.

## SSL/TLS 프로토콜

HTTPS는?  
 HTTP 통신을 하는 소켓 부분에서 SSL 혹은 TLS라는 프로토콜 사용하여 **서버 인증과 데이터 암호화**를 진행(SSL 표준화되어 TLS로 이름 바뀜 같은 개념)

- CA를 통한 인증서 사용
- 대칭 키,공개 키 암호화 방식을 모두 사용

HTTPS를 사용하면 브라우저가 서버의 응답과 함께 전달된 인증서를 확인 가능  
 **CA** : 인증서를 발급해주는 공인된 기관

1.  **서버**는 **인증서를 발급**받기 위해 **CA로 서버의 정보와 공개 키**를 전달
2.  **CA**는 **서버에게서 전달된 정보와 공개 키**를 **CA의 비밀 키**로 **암호화하여 인증서를 발급**=>해당 암호화 인증서는 CA의 공개키로 열 수 있음
3.  서버는 이제 인증서를 갖게 됨.클라이언트가 서버에게 요청을 보내면 서버는 발급받은 인증서를 클라이언트에게 보내줌.
4.  클라이언트에 브라우저는 CA들의 리스트와 공개키를 내장하고 있어서 해당 인증서를 CA가 발급한 것인지 확인, 리스트에 있는 CA라면 공개키를 사용해 인증서의 복호화를 시도
5.  CA 비밀키로 암호화 된 인증서가 정상적이라면 복호화가 성공되지만 아니라면 복호화가 실패 => 실패하면 인증서가 신뢰할 수 없는 인증서인 것을 확인하게 됨

**대칭 키 전달**  
 서버의 인증서를 성공적으로 복호화하면 **서버의 공개키를 확보**할 수 있음.  
 **공개 키를 사용해서 데이터를 암호화**하는 것인가??? -> 이는 **복잡한 연산이 발생하여 하지 않음**  
 서버의 공개키는 **클라이언트와 서버가 함께 사용하게 될 대칭키**를 주고 받을 때 사용

클라이언트가 서버로 대칭 키를 보낼 때 서버의 공개 키를 사용해서 암호화하여 보낸다면 서버의 비밀 키를 가지고 있는게 아닌 이상 해당 대칭 키를 복호화 할 수 없으므로 탈취 할 수 없음  
 클라이언트는 데이터를 암호화하여 주고받을 때 대칭키를 사용. 생성한 대칭키를 서버의 공개키로 암호화하여 전달. 해당 공개키를 서버에서 비밀키로 복호화하면 클라이언트에 대칭키를 확인할 수 있음

정리

1. 서버는 서버의 정보와 공개키를 CA로 보냄
2. CA는 서버에게 전달온 정보와 공개키를 CA의 비밀키로 감싸서 인증서를 만들고 해당 인증서를 서버에게 전달함.
3. 이제 클라이언트가 서버에게 요청을 보내면 서버는 인증서를 클라이언트에게 전달
4. 클라이언트는 CA에 공개키를 가지고 있어서 인증서를 복호화할 수 있음
5. 복호화가 성공적이라면 CA에게 인증받은 인증서, 실패한다면 인증받지 않은 인증서
6. 클라이언트가 인증서 복호화에 성공한다면? 서버의 공개키를 확인할 수 있음
7. 클라이언트는 데이터를 암호화하여 주고 받을 때 사용할 대칭키를 생성함
8. 해당 대칭키를 서버의 공개키로 감싸서 서버에게 전달!!
9. 클라이언트가 데이터 대칭키를 서버의 공개키로 감쌓기 때문에 해당 공개키에 대한 비밀키를 가지고 있는 서버만 해당 대칭키를 확인할 수 있음.
10. 이렇게 되면 서로 같은 대칭키를 갖게 됨. 이제 HTTPS 요청을 받을 때 이 대칭키를 사용해서 암호화하여 전달하게 됨.
11. 중간에서 대칭키를 탈취하지 못하였으니, 대칭키로 인한 암호화와 복호화가 서로 이뤄질 수 있게 됨.

서버에서 정보와 공개키를 CA에 전달  
 -> CA에 비밀키로 해당 전달 정보를 감싸고 인증서를 만듬  
 -> 인증서를 서버에게 보냄 -> 클라이언트가 서버에게 요청  
 -> 서버가 클라이언트에 인증서가 전달 -> 클라이언트에서 인증서를 풀어서 서버의 공개키를 확인  
 -> 클라이언트가 데이터 전달용 대칭키를 만들고 풀어본 서버 공개키로 암호화해서 대칭키를 서버에 전달  
 -> 서버는 비밀키를 이용해서 해당 공개키를 열어보고 대칭키를 갖게 됨.  
 -> 클라이언트와 서버는 이제 이 대칭키를 가지고 데이터를 서로 복호화 암호화를 진행.
